<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>çŸ¥è‚²è¿·è·¯ã‚¢ãƒ—ãƒª</title>
    <style>
        /* å…¨ä½“ã®ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
            background-color: #FFF9C4;
            /* ãƒ‘ã‚¹ãƒ†ãƒ«ã‚¤ã‚¨ãƒ­ãƒ¼ */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ */
        #menu {
            display: flex;
            flex-direction: column;
            gap: 20px;
            text-align: center;
            width: 90%;
            max-width: 400px;
        }

        h1 {
            color: #FF7043;
            /* ãƒãƒƒãƒ—ãªã‚ªãƒ¬ãƒ³ã‚¸ */
            font-size: clamp(2rem, 5vw, 3rem);
            margin-bottom: 20px;
            text-shadow: 2px 2px 0px #FFF;
        }

        .mode-btn {
            background-color: #4DB6AC;
            /* ãƒ‘ã‚¹ãƒ†ãƒ«ã‚°ãƒªãƒ¼ãƒ³ */
            color: white;
            border: none;
            border-radius: 20px;
            padding: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 6px 0 #00897B;
            transition: transform 0.1s, box-shadow 0.1s;
            width: 100%;
        }

        .mode-btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #00897B;
        }

        .mode-btn.small {
            padding: 15px 10px;
            font-size: 1.2rem;
            flex: 1;
        }

        .mode-btn.purple {
            background-color: #9575CD;
            box-shadow: 0 6px 0 #5E35B1;
        }

        .mode-btn.purple:active {
            box-shadow: 0 2px 0 #5E35B1;
        }

        /* ã‚²ãƒ¼ãƒ ç”»é¢ */
        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 10px;
        }

        /* æ¨ªç”»é¢ï¼ˆã‚¿ãƒ–ãƒ¬ãƒƒãƒˆãƒ»PCï¼‰å¯¾å¿œ */
        @media (min-width: 600px) and (orientation: landscape) {
            #game-container {
                flex-direction: row;
                gap: 20px;
            }

            #controls-area {
                display: flex !important;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                width: 300px;
                /* å›ºå®šå¹… */
            }
        }

        /* ã‚­ãƒ£ãƒ³ãƒã‚¹ */
        canvas {
            background-color: #FFFFFF;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            touch-action: none;
            /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–èª¿æ•´ã¯JSã§è¡Œã†ãŒã€CSSã§ã‚‚ä¸Šé™è¨­å®š */
            max-width: 95vw;
            max-height: 80vh;
        }

        /* UIãƒ‘ãƒãƒ«ï¼ˆä¸Šéƒ¨ãƒãƒ¼ï¼‰ */
        #ui-panel {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            height: 60px;
        }

        .nav-btn {
            background-color: #FFAB91;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 0 #D84315;
            color: white;
            flex-shrink: 0;
        }

        .nav-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #D84315;
        }

        #status-text {
            font-size: clamp(1rem, 4vw, 1.4rem);
            font-weight: bold;
            color: #555;
            text-align: center;
            flex-grow: 1;
            white-space: nowrap;
        }

        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ (Mode Bç”¨) */
        #controls-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            /* ç¸¦ç”»é¢æ™‚ã¯å¹…ã„ã£ã±ã„ */
            max-width: 400px;
            padding-bottom: 40px;
            /* ã‚¿ã‚¹ã‚¯ãƒãƒ¼ã¨ã®é‡ãªã‚Šé˜²æ­¢ */
            justify-content: flex-end;
            /* ä¸‹å¯„ã› */
        }

        #d-pad {
            display: none;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
            margin-top: 5px;
            /* ãƒãƒ¼ã‚¸ãƒ³å‰Šæ¸› */
        }

        button {
            touch-action: manipulation;
        }

        .d-btn {
            background-color: #64B5F6;
            border: none;
            border-radius: 15px;
            width: 70px;
            /* å°‘ã—å°ã•ãã—ã¦ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
            height: 55px;
            font-size: 2rem;
            color: white;
            cursor: pointer;
            box-shadow: 0 5px 0 #1565C0;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .d-btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #1565C0;
        }

        #d-pad-sub {
            margin-top: 10px;
            /* ãƒãƒ¼ã‚¸ãƒ³å‰Šæ¸› */
            margin-bottom: 20px;
            /* ä¸‹ã«ä½™ç™½ */
            display: none;
            width: 100%;
            text-align: center;
        }

        #undo-btn {
            background-color: #F06292;
            box-shadow: 0 5px 0 #AD1457;
            font-size: 1rem;
            width: 150px;
            margin: 0 auto;
        }

        #undo-btn:active {
            box-shadow: 0 2px 0 #AD1457;
        }

        /* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .message-box {
            background: orange;
            padding: 20px;
            width: 80%;
            max-width: 400px;
            border-radius: 20px;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 1.5rem;
            border: 5px solid white;
            animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popUp {
            0% {
                transform: scale(0);
            }

            100% {
                transform: scale(1);
            }
        }

        * {
            box-sizing: border-box;
        }
    </style>
</head>

<body>

    <!-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ -->
    <div id="menu">
        <h1>ğŸ¶ çŸ¥è‚²è¿·è·¯ ğŸ</h1>
        <button class="mode-btn" onclick="startGame('A')">âœï¸ ãŠãˆã‹ãè¿·è·¯</button>

        <div style="margin-top: 30px; width: 100%;">
            <h2 style="color: #9575CD; margin-bottom: 10px; font-size: 1.5rem;">ğŸ—ºï¸ ã¼ã†ã‘ã‚“è¿·è·¯</h2>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="mode-btn purple small" onclick="startGame('B', 1)">Lv.1</button>
                <button class="mode-btn purple small" onclick="startGame('B', 11)">Lv.2</button>
                <button class="mode-btn purple small" onclick="startGame('B', 21)">Lv.3</button>
            </div>
        </div>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
    <div id="game-container">

        <!-- ã‚­ãƒ£ãƒ³ãƒã‚¹ã¨ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ©ãƒƒãƒ‘ãƒ¼ -->
        <div style="display:flex; flex-direction:column; align-items:center;">
            <div id="ui-panel">
                <button class="nav-btn" onclick="goHome()">ğŸ </button>
                <div id="status-text"></div>
                <div style="width: 50px;"></div>
            </div>
            <canvas id="gameCanvas"></canvas>
        </div>

        <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ (å³å´ or ä¸‹å´) -->
        <div id="controls-area">
            <div id="d-pad">
                <div style="grid-column: 2;">
                    <button class="d-btn" onclick="handleDPad('UP')">â¬†ï¸</button>
                </div>
                <div style="grid-column: 1; grid-row: 2;">
                    <button class="d-btn" onclick="handleDPad('LEFT')">â¬…ï¸</button>
                </div>
                <div style="grid-column: 2; grid-row: 2;">
                    <button class="d-btn" onclick="handleDPad('DOWN')">â¬‡ï¸</button>
                </div>
                <div style="grid-column: 3; grid-row: 2;">
                    <button class="d-btn" onclick="handleDPad('RIGHT')">â¡ï¸</button>
                </div>
            </div>

            <div id="d-pad-sub">
                <button id="undo-btn" class="d-btn" onclick="handleUndo()">ï¼‘ã¤ã‚‚ã©ã‚‹</button>
            </div>
        </div>
    </div>

    <!-- ã‚¯ãƒªã‚¢ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ -->
    <div id="message-overlay">
        <div class="message-box"></div>
    </div>

    <script>
        /**
         * setting
         */
        /**
     * setting
     */
        const TOTAL_LEVELS = 40; // LV4ã¾ã§å®Ÿè£…

        /**
         * å¤‰æ•°
         */
        let currentMode = null;
        let currentLevel = 1;
        let canvas, ctx;
        let tileSize = 0;

        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
        let levelMap = [];
        let gridSize = 10;
        let playerPos = { x: 1, y: 1 };

        let targetItemCount = 0; // é›†ã‚ã‚‹ã¹ãç›®æ¨™æ•°ï¼ˆLV3ç”¨ï¼‰
        let isExactCountMode = false; // ã´ã£ãŸã‚Šé›†ã‚ã‚‹ãƒ¢ãƒ¼ãƒ‰ã‹
        let hasKey = false; // LV4ç”¨: éµã‚’æŒã£ã¦ã„ã‚‹ã‹

        let isGameClear = false;

        // ãƒ¢ãƒ¼ãƒ‰Aç”¨
        let isDrawing = false;
        let drawPath = [];

        // ãƒ¢ãƒ¼ãƒ‰Bç”¨
        let historyStack = [];
        let visitedTiles = [];

        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨
        let fireworks = [];

        /**
         * è¿·è·¯ç”Ÿæˆã‚¯ãƒ©ã‚¹
         */
        class MazeGenerator {
            static generate(level) {
                // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
                let size = 10;
                if (level > 10) size = 12; // LV2~ ã¯å°‘ã—åºƒã

                gridSize = size;
                let map = Array(size).fill(0).map(() => Array(size).fill(1));

                // ã‚¹ã‚¿ãƒ¼ãƒˆã¯å¸¸ã«(1,1)
                let start = { x: 1, y: 1 };

                // è¿·è·¯ç”Ÿæˆåˆ†å²
                if (level <= 10) {
                    // LV1
                    this.carve(map, start.x, start.y, 0.5);
                    this.setDefaultStartGoal(map, size, start);
                    return this.placeItemsStandard(map, start, this.getGoal(map, size), level);
                } else if (level <= 20) {
                    // LV2
                    this.carve(map, start.x, start.y, 1.0);
                    this.setDefaultStartGoal(map, size, start);
                    return this.placeItemsStandard(map, start, this.getGoal(map, size), level);
                } else if (level <= 30) {
                    // LV3
                    this.carve(map, start.x, start.y, 0.5);
                    this.addLoops(map, 3 + Math.floor((level - 20) / 3));
                    this.setDefaultStartGoal(map, size, start);
                    return this.placeItemsLV3(map, start, this.getGoal(map, size), level);
                } else {
                    // LV4: Key & Door (Loop)
                    return this.generateLevel4(map, size, level);
                }
            }

            static setDefaultStartGoal(map, size, start) {
                let gx = size - 2;
                let gy = size - 2;
                while (map[gy][gx] === 1) {
                    if (gx > 1) gx--;
                    else { gx = size - 2; gy--; }
                }
                map[start.y][start.x] = 2;
                map[gy][gx] = 3;
            }

            static getGoal(map, size) {
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        if (map[y][x] === 3) return { x, y };
                    }
                }
                return { x: size - 2, y: size - 2 };
            }

            static generateLevel4(map, size, level) {
                // LV4: ãƒ«ãƒ¼ãƒ—è¿·è·¯ã€‚éµã‚’å–ã£ã¦æˆ»ã‚‰ãªã„ã§ã‚´ãƒ¼ãƒ«ã¸ã€‚
                // æ§‹æˆ: ã‚¹ã‚¿ãƒ¼ãƒˆ â†’ (é•·ã„é“) â†’ éµ â†’ (é•·ã„é“) â†’ æ‰‰ â†’ ã‚´ãƒ¼ãƒ«

                // 1. å…¨éƒ¨å£ã«ã™ã‚‹ï¼ˆåˆæœŸåŒ–æ¸ˆã¿ï¼‰

                // 2. ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ (1,1)
                let sx = 1, sy = 1;
                map[sy][sx] = 2;

                // 3. æ‰‰åœ°ç‚¹ã¨ã‚´ãƒ¼ãƒ«åœ°ç‚¹ã‚’æ±ºã‚ã‚‹
                // ã‚¹ã‚¿ãƒ¼ãƒˆã®ã™ãè¿‘ãã«æ‰‰ã‚’ç½®ãã“ã¨ã§ã€Œä¸€è¦‹è¿‘ã„ã‘ã©é€šã‚Œãªã„ã€çŠ¶æ³ã‚’ä½œã‚‹
                // ä¾‹ãˆã° (1,2) ã‚’æ‰‰ã€(1,3) ã‚’ã‚´ãƒ¼ãƒ«ã«ã™ã‚‹
                // ãŸã ã—ã€(1,2)ã«è¡Œã‘ãªã„ã‚ˆã†ã«è¿‚å›ãƒ«ãƒ¼ãƒˆã‚’ä½œã‚‹å¿…è¦ãŒã‚ã‚‹

                // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ«ãƒ¼ãƒ—ã‚’ä½œã‚‹ãŸã‚ã€å¤–å‘¨ã«è¿‘ã„ãƒ«ãƒ¼ãƒˆã‚’æ˜ã‚‹
                // ã‚¹ã‚¿ãƒ¼ãƒˆã‹ã‚‰æ™‚è¨ˆå›ã‚Šã«æ˜ã£ã¦ã„ãã‚¤ãƒ¡ãƒ¼ã‚¸

                let path = [];
                let cx = sx, cy = sy;

                // ç°¡æ˜“çš„ãªãƒ«ãƒ¼ãƒ—ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯:
                // æ ¼å­çŠ¶ã®ãƒã‚¤ãƒ³ãƒˆã‚’å·¡å›ã™ã‚‹ãƒ‘ã‚¹ã‚’ä½œã‚‹
                // å˜ç´”ã«å¤–å‘¨ã‚’ãã‚‹ã£ã¨å›ã‚‹ã ã‘ã ã¨ç°¡å˜ã™ãã‚‹ã®ã§ã€Recursive Backtrackerã§ä¸€æœ¬é“ã‚’ä½œã£ãŸã‚ã¨ã€
                // ã‚¹ã‚¿ãƒ¼ãƒˆä»˜è¿‘ã¨ã‚´ãƒ¼ãƒ«ä»˜è¿‘ã‚’æ¥ç¶šã™ã‚‹ï¼ˆæ‰‰ã§ï¼‰

                this.carve(map, sx, sy, 0.8);

                // ã‚´ãƒ¼ãƒ«å€™è£œã‚’æ¢ã™ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆã‹ã‚‰ä¸€ç•ªé ã„ç‚¹ï¼‰
                let distMap = this.getDistanceMap(map, { x: sx, y: sy });
                let maxDist = -1;
                let gx = sx, gy = sy;

                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        if (distMap[y][x] > maxDist) {
                            maxDist = distMap[y][x];
                            gx = x; gy = y;
                        }
                    }
                }

                // ã“ã“ã§ã€ã‚´ãƒ¼ãƒ«(gx, gy)ã®æ‰‹å‰ã«æ‰‰ã‚’ç½®ããŸã„ã€‚
                // ã—ã‹ã—ã€Œãƒ«ãƒ¼ãƒ—ã—ã¦æˆ»ã‚‹ã€ã¨ã„ã†è¦ä»¶ãªã®ã§ã€
                // ã€Œã‚¹ã‚¿ãƒ¼ãƒˆã€ã¨ã€Œã‚´ãƒ¼ãƒ«ã€ãŒå®Ÿã¯å£ä¸€æšï¼ˆã¾ãŸã¯çŸ­ã„è·é›¢ï¼‰ã§éš£æ¥ã—ã¦ã„ã¦ã€
                // é–“ã«æ‰‰ãŒã‚ã‚‹æ§‹é€ ãŒæœ›ã¾ã—ã„ã€‚

                // å¼·åˆ¶çš„ã«ãƒ«ãƒ¼ãƒ—ã‚’ä½œã‚‹:
                // ä»Šã®ã‚´ãƒ¼ãƒ«åœ°ç‚¹ã‹ã‚‰ã€ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã«ãƒ»ã¾ãŸã¯ã‚¹ã‚¿ãƒ¼ãƒˆã®éš£æ¥ç‚¹ã«å‘ã‹ã£ã¦æ˜ã‚‹
                // å£ã‚’è²«é€šã•ã›ã¦é“ã‚’ã¤ãªã’ã‚‹

                // ã‚¹ã‚¿ãƒ¼ãƒˆã®éš£ (2,1) ã¾ãŸã¯ (1,2) ãŒå£ãªã‚‰ã€ãã“ã‚’æ‰‰ã«ã™ã‚‹
                let doorX = -1, doorY = -1;

                // ã‚¹ã‚¿ãƒ¼ãƒˆå‘¨è¾ºã§å£ã®å ´æ‰€ã‚’æ¢ã™
                if (map[sy + 1][sx] === 1) { doorX = sx; doorY = sy + 1; }
                else if (map[sy][sx + 1] === 1) { doorX = sx + 1; doorY = sy; }

                if (doorX !== -1) {
                    // ãã®æ‰‰ã®å‘ã“ã†å´ã‚’ã‚´ãƒ¼ãƒ«ã«ã™ã‚‹
                    let goalX = doorX + (doorX - sx);
                    let goalY = doorY + (doorY - sy);

                    // ã‚´ãƒ¼ãƒ«äºˆå®šåœ°ãŒç¯„å›²å†…ãªã‚‰
                    if (goalX > 0 && goalX < size - 1 && goalY > 0 && goalY < size - 1) {
                        map[doorY][doorX] = 6; // 6 = Door
                        map[goalY][goalX] = 3; // 3 = Goal

                        // æ—¢å­˜ã®è¿·è·¯ã®ã€Œè¡Œãæ­¢ã¾ã‚Šã€ã‹ã‚‰ã€ã“ã®ã‚´ãƒ¼ãƒ«åœ°ç‚¹ã¸é“ã‚’ã¤ãªã’ã‚‹å¿…è¦ãŒã‚ã‚‹
                        // ä¸€ç•ªé ã„ç‚¹(gx, gy)ã‹ã‚‰ goalX, goalY ã¸ã¨é“ã‚’æ˜ã‚Šã¤ãªã’ã‚‹
                        this.forcePath(map, { x: gx, y: gy }, { x: goalX, y: goalY });
                    } else {
                        // å¤±æ•—ã—ãŸã‚‰æ™®é€šã®é…ç½®
                        map[gy][gx] = 3;
                        // é©å½“ãªãƒ‘ã‚¹ä¸Šã«æ‰‰ã‚’ç½®ã
                        // ...
                        this.simpleDoorLayout(map, sx, sy, gx, gy);
                    }
                } else {
                    map[gy][gx] = 3;
                    this.simpleDoorLayout(map, sx, sy, gx, gy);
                }

                // éµã®é…ç½®: ã‚¹ã‚¿ãƒ¼ãƒˆã‹ã‚‰ï¼ˆæ‰‰ã‚’é€šã‚‰ãšã«ï¼‰ä¸€ç•ªé ã„å ´æ‰€ã«ç½®ã
                let pathWithoutDoor = this.findPath(map, { x: sx, y: sy }, { x: gx, y: gy }, true); // blockDoor=true
                // å®Ÿéš›ã«ã¯ findPath ã¯ BFS ãªã®ã§æœ€çŸ­çµŒè·¯ã€‚
                // ä¸€ç•ªé ã„åœ°ç‚¹ã‚’å–å¾—ã™ã‚‹é–¢æ•°ãŒå¿…è¦ã ãŒã€ç°¡æ˜“çš„ã« path ã®ä¸­ç‚¹ã‹ã€
                // ã‚ã‚‹ã„ã¯å†åº¦ Distance Map ã‚’ä½œã‚‹

                // startã‹ã‚‰ã®è·é›¢ãƒãƒƒãƒ—ï¼ˆæ‰‰ã¯å£æ‰±ã„ï¼‰
                let dist = this.getDistanceMap(map, { x: sx, y: sy }, true);
                let keyX = sx, keyY = sy, maxD = -1;

                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        if (map[y][x] === 0 && dist[y][x] > maxD) { // é“ã®ã¿
                            maxD = dist[y][x];
                            keyX = x; keyY = y;
                        }
                    }
                }
                map[keyY][keyX] = 5; // 5 = Key

                return map;
            }

            static simpleDoorLayout(map, sx, sy, gx, gy) {
                // å˜ç´”ã«ã‚´ãƒ¼ãƒ«æ‰‹å‰ã«æ‰‰ã‚’ç½®ã
                // ã‚´ãƒ¼ãƒ«ã®éš£æ¥ãƒã‚¹ã‚’æ¢ã™
                const dirs = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];
                for (let d of dirs) {
                    let nx = gx + d.x;
                    let ny = gy + d.y;
                    if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && map[ny][nx] === 0) {
                        map[ny][nx] = 6; // Door
                        break;
                    }
                }
            }

            static forcePath(map, start, end) {
                // startã‹ã‚‰endã¾ã§ç›´ç·šçš„ï¼ˆã¾ãŸã¯Lå­—ï¼‰ã«ç„¡ç†ã‚„ã‚Šæ˜ã‚‹
                let cx = start.x, cy = start.y;
                while (cx !== end.x || cy !== end.y) {
                    map[cy][cx] = 0;
                    if (cx < end.x) cx++;
                    else if (cx > end.x) cx--;
                    else if (cy < end.y) cy++;
                    else if (cy > end.y) cy--;
                }
                map[end.y][end.x] = 0;
            }

            static getDistanceMap(map, start, blockDoor = false) {
                let d = Array(gridSize).fill(0).map(() => Array(gridSize).fill(-1));
                let q = [start];
                d[start.y][start.x] = 0;

                while (q.length > 0) {
                    let curr = q.shift();
                    const dirs = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];
                    for (let dir of dirs) {
                        let nx = curr.x + dir.x;
                        let ny = curr.y + dir.y;
                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                            // 1:Wall, 6:Door(if blocked)
                            let isWall = map[ny][nx] === 1 || (blockDoor && map[ny][nx] === 6);
                            // Start(2), Goal(3), Key(5) are walkable
                            // Door(6) is walkable if !blockDoor
                            if (!isWall && d[ny][nx] === -1) {
                                d[ny][nx] = d[curr.y][curr.x] + 1;
                                q.push({ x: nx, y: ny });
                            }
                        }
                    }
                }
                return d;
            }

            static carve(map, x, y, randomness) {
                const directions = [
                    { dx: 0, dy: -2 }, { dx: 0, dy: 2 }, { dx: -2, dy: 0 }, { dx: 2, dy: 0 }
                ];

                // ã‚·ãƒ£ãƒƒãƒ•ãƒ«
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }

                map[y][x] = 0;

                for (const dir of directions) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;

                    if (nx > 0 && nx < gridSize - 1 && ny > 0 && ny < gridSize - 1 && map[ny][nx] === 1) {
                        map[y + dir.dy / 2][x + dir.dx / 2] = 0;
                        this.carve(map, nx, ny, randomness);
                    }
                }
            }

            static findPath(map, start, goal, blockDoor = false) {
                const q = [[start]];
                const visited = new Set();
                visited.add(`${start.x},${start.y}`);

                // å˜ç´”BFSã§ä¸€ã¤è¦‹ã¤ã‘ã‚‹
                while (q.length > 0) {
                    const path = q.shift();
                    const curr = path[path.length - 1];

                    if (curr.x === goal.x && curr.y === goal.y) return path;

                    const dirs = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];
                    this.shuffle(dirs); // ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’æŒãŸã›ã‚‹

                    for (const d of dirs) {
                        const nx = curr.x + d.x;
                        const ny = curr.y + d.y;
                        let isWalkable = (map[ny][nx] !== 1);
                        if (blockDoor && map[ny][nx] === 6) isWalkable = false;

                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && isWalkable) {
                            if (!visited.has(`${nx},${ny}`)) {
                                visited.add(`${nx},${ny}`);
                                q.push([...path, { x: nx, y: ny }]);
                            }
                        }
                    }
                }
                return [];
            }

            static shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            static addLoops(map, count) {
                let added = 0;
                let attempts = 0;
                while (added < count && attempts < 100) {
                    attempts++;
                    let x = Math.floor(Math.random() * (gridSize - 2)) + 1;
                    let y = Math.floor(Math.random() * (gridSize - 2)) + 1;

                    if (map[y][x] === 1) {
                        let roads = 0;
                        if (map[y - 1][x] === 0) roads++;
                        if (map[y + 1][x] === 0) roads++;
                        if (map[y][x - 1] === 0) roads++;
                        if (map[y][x + 1] === 0) roads++;

                        if (roads >= 2) {
                            map[y][x] = 0;
                            added++;
                        }
                    }
                }
            }

            static placeItemsStandard(map, start, goal, level) {
                const path = this.findPath(map, start, goal);
                if (!path) return map;
                let itemCount = 2 + Math.floor(level / 5);
                if (level > 10) itemCount += 2;

                const candidates = path.slice(1, path.length - 1);
                this.shuffle(candidates);

                let placed = 0;
                for (const p of candidates) {
                    if (placed >= itemCount) break;
                    map[p.y][p.x] = 4;
                    placed++;
                }

                targetItemCount = placed;
                isExactCountMode = false;
                return map;
            }

            static placeItemsLV3(map, start, goal, level) {
                // LV3: åˆ†å²ã‚ã‚Š & ã²ã£ã‹ã‘ã‚ã‚Š (Active Branch Baiting)
                // ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ :
                // 1. æ­£è§£ãƒ«ãƒ¼ãƒˆ (Solution Path) ã‚’ç¢ºå®š
                // 2. æ­£è§£ãƒ«ãƒ¼ãƒˆä¸Šã«ã€Œç›®æ¨™æ•°ã€ã®ã‚Šã‚“ã”ã‚’é…ç½®
                // 3. æ­£è§£ãƒ«ãƒ¼ãƒˆã‹ã‚‰åˆ†å²ã™ã‚‹ã€Œä¸æ­£è§£ãƒ«ãƒ¼ãƒˆ (Branch)ã€ã‚’æ¤œå‡º
                // 4. ä¸æ­£è§£ãƒ«ãƒ¼ãƒˆä¸Šã«ã€Œãƒ€ãƒŸãƒ¼ã‚Šã‚“ã”ã€ã‚’é…ç½®ï¼ˆã“ã‚ŒãŒã²ã£ã‹ã‘ã«ãªã‚‹ï¼‰

                const path = this.findPath(map, start, goal);
                if (!path || path.length === 0) return map;

                // ç›®æ¨™æ•°
                let target = 3 + (level % 3);
                targetItemCount = target;
                isExactCountMode = true;

                const pathSet = new Set(path.map(p => `${p.x},${p.y}`));

                // 2. æ­£è§£ãƒ«ãƒ¼ãƒˆé…ç½®
                const candidates = path.slice(1, path.length - 1);
                this.shuffle(candidates);
                let placed = 0;
                for (const p of candidates) {
                    if (placed >= target) break;
                    map[p.y][p.x] = 4;
                    placed++;
                }
                if (placed < target) targetItemCount = placed;

                // 3. åˆ†å²ãƒ«ãƒ¼ãƒˆæ¤œå‡º
                let branches = [];
                for (const p of path) {
                    const dirs = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];
                    this.shuffle(dirs);
                    for (const d of dirs) {
                        const nx = p.x + d.x;
                        const ny = p.y + d.y;

                        // é“ã§ã‚ã‚Šã€ã‹ã¤æ­£è§£ãƒ«ãƒ¼ãƒˆã«å«ã¾ã‚Œã¦ã„ãªã„ãƒã‚¹ï¼åˆ†å²ã®å§‹ã¾ã‚Š
                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                            if (map[ny][nx] === 0 && !pathSet.has(`${nx},${ny}`)) {
                                // ã“ã®åˆ†å²ã®å…ˆã«ã‚ã‚‹ãƒã‚¹ã‚’ã„ãã¤ã‹åé›†ã™ã‚‹
                                const branchCells = this.collectBranchCells(map, nx, ny, pathSet);
                                if (branchCells.length > 0) {
                                    branches.push(branchCells);
                                }
                            }
                        }
                    }
                }

                // 4. ãƒ€ãƒŸãƒ¼é…ç½® (åˆ†å²ãƒ«ãƒ¼ãƒˆå„ªå…ˆ)
                // åˆ†å²ãŒè¦‹ã¤ã‹ã‚Œã°ã€ãã“ã«ç©æ¥µçš„ã«ç½®ã
                this.shuffle(branches);

                let dummyCountTotal = 0;
                const maxDummy = 5 + (level % 3);

                // å„åˆ†å²ã«å°‘ã—ãšã¤ç½®ã
                for (const branch of branches) {
                    if (dummyCountTotal >= maxDummy) break;

                    // ãã®åˆ†å²ã«ã„ãã¤ç½®ãã‹ï¼ˆ1ã€œ2å€‹ï¼‰
                    const countInThisBranch = 1 + Math.floor(Math.random() * 2);

                    this.shuffle(branch);
                    let placedInBranch = 0;
                    for (const cell of branch) {
                        if (placedInBranch >= countInThisBranch) break;
                        map[cell.y][cell.x] = 4;
                        placedInBranch++;
                        dummyCountTotal++;
                    }
                }

                // ã‚‚ã—åˆ†å²ãŒå°‘ãªã™ãã¦ãƒ€ãƒŸãƒ¼ãŒç½®ã‘ãªã‹ã£ãŸå ´åˆã€ãƒ©ãƒ³ãƒ€ãƒ é…ç½®ã§åŸ‹ã‚åˆã‚ã›
                let attempts = 0;
                while (dummyCountTotal < 2 && attempts < 100) {
                    attempts++;
                    let x = Math.floor(Math.random() * gridSize);
                    let y = Math.floor(Math.random() * gridSize);
                    if (map[y][x] === 0 && !pathSet.has(`${x},${y}`) && map[y][x] !== 4) {
                        map[y][x] = 4;
                        dummyCountTotal++;
                    }
                }

                return map;
            }

            // åˆ†å²ã®å…ˆã®é“ãƒã‚¹ã‚’åé›†ã™ã‚‹ï¼ˆæ·±ã•3ãã‚‰ã„ã¾ã§ï¼‰
            static collectBranchCells(map, startX, startY, excludeSet) {
                let cells = [];
                let q = [{ x: startX, y: startY }];
                let visited = new Set();
                visited.add(`${startX},${startY}`);

                // å…ƒã®ãƒ‘ã‚¹ã‚‚è¨ªå•æ¸ˆã¿ã¨ã—ã¦æ‰±ã£ã¦é€†æµé˜²æ­¢
                excludeSet.forEach(s => visited.add(s));

                let limit = 10; // æ¢ç´¢ä¸Šé™
                while (q.length > 0 && limit > 0) {
                    limit--;
                    const curr = q.shift();
                    cells.push(curr);

                    const dirs = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];
                    for (const d of dirs) {
                        const nx = curr.x + d.x;
                        const ny = curr.y + d.y;
                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                            if (map[ny][nx] === 0 && !visited.has(`${nx},${ny}`)) {
                                visited.add(`${nx},${ny}`);
                                q.push({ x: nx, y: ny });
                            }
                        }
                    }
                }
                return cells;
            }

            // Duplicate methods removed


        /**
         * åˆæœŸåŒ–
         */
        window.onload = () => {
                canvas = document.getElementById('gameCanvas');
                ctx = canvas.getContext('2d');

                canvas.addEventListener('mousedown', startDraw);
                canvas.addEventListener('mousemove', drawing);
                canvas.addEventListener('mouseup', endDraw);
                canvas.addEventListener('mouseout', endDraw);
                canvas.addEventListener('touchstart', startDraw, { passive: false });
                canvas.addEventListener('touchmove', drawing, { passive: false });
                canvas.addEventListener('touchend', endDraw);

                window.addEventListener('keydown', (e) => {
                    if (currentMode === 'B' && !isGameClear) {
                        if (e.key === 'ArrowUp') handleDPad('UP');
                        if (e.key === 'ArrowDown') handleDPad('DOWN');
                        if (e.key === 'ArrowLeft') handleDPad('LEFT');
                        if (e.key === 'ArrowRight') handleDPad('RIGHT');
                    }
                });

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            };

        function resizeCanvas() {
            // UIã®é«˜ã•ã‚’è€ƒæ…®ã—ã¦ãƒªã‚µã‚¤ã‚º
            const uiHeight = document.getElementById('ui-panel').offsetHeight || 60;
            const controlsHeight = (currentMode === 'B' && window.innerWidth < 600) ? 200 : 0; // ãƒ¢ãƒã‚¤ãƒ«ç¸¦ã®æ™‚ã®ã¿è€ƒæ…®

            // æ¨ªå¹…åŸºæº–ã¨é«˜ã•åŸºæº–ã®å°ã•ã„æ–¹ã‚’å–ã‚‹
            const maxW = window.innerWidth - 20;
            const maxH = window.innerHeight - uiHeight - controlsHeight - 20;

            const size = Math.floor(Math.min(maxW, maxH));

            // ã‚°ãƒªãƒƒãƒ‰ã«åˆã‚ã›ã¦èª¿æ•´
            const adjustedSize = Math.floor(size / gridSize) * gridSize;

            canvas.width = adjustedSize;
            canvas.height = adjustedSize;
            tileSize = adjustedSize / gridSize;
            draw();
        }

        /**
         * ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡
         */
        function startGame(mode, level = 1) {
            currentMode = mode;
            currentLevel = level;

            document.getElementById('menu').style.display = 'none';
            document.getElementById('game-container').style.display = 'flex';
            document.getElementById('message-overlay').style.display = 'none';

            const dPad = document.getElementById('d-pad');
            const dPadSub = document.getElementById('d-pad-sub');
            const statusText = document.getElementById('status-text');

            // ãƒãƒƒãƒ—ç”Ÿæˆ
            levelMap = MazeGenerator.generate(currentLevel);

            if (mode === 'B') {
                dPad.style.display = 'grid';
                dPadSub.style.display = 'block';
                updateStatusTextB();
            } else {
                dPad.style.display = 'none';
                dPadSub.style.display = 'none';
                statusText.textContent = 'ã‚†ã³ã§ãªãã£ã¦ã­ï¼';
            }

            // ãƒãƒƒãƒ—è¨­å®šå¾Œã«ãƒªã‚µã‚¤ã‚ºï¼ˆgridSizeå¤‰ã‚ã‚‹ãŸã‚ï¼‰
            resizeCanvas();
            resetGame();
            loop();
        }

        function updateStatusTextB() {
            const collected = getCollectedCount();
            const status = document.getElementById('status-text');

            if (isExactCountMode) {
                status.textContent = `Lv.${currentLevel} ğŸã‚’ ${targetItemCount}ã“ ã‚ã¤ã‚ã¦ã­ (ã„ã¾:${collected})`;
                if (collected > targetItemCount) {
                    status.textContent = `ã¨ã‚Šã™ãã ã‚ˆï¼ ğŸã¯ ${targetItemCount}ã“ ã ã‘ï¼`;
                    status.style.color = "red";
                } else {
                    status.style.color = "#555";
                }
            } else if (levelMap.flat().includes(5) || levelMap.flat().includes(6) || currentLevel >= 31) {
                // LV4: Key
                if (hasKey) {
                    status.textContent = `Lv.${currentLevel} ã‹ãğŸ”‘ã‚’ã‚‚ã£ã¦ã„ã‚‹ã‚ˆï¼ã‚´ãƒ¼ãƒ«ã¸ï¼`;
                    status.style.color = "blue";
                } else {
                    status.textContent = `Lv.${currentLevel} ã‹ãğŸ”‘ã‚’ã•ãŒã—ã¦ã­`;
                    status.style.color = "#555";
                }
            } else {
                const remaining = targetItemCount - collected;
                status.textContent = `Lv.${currentLevel} ğŸã‚ã¨ ${remaining}ã“ï¼`;
                status.style.color = "#555";
            }
        }

        function getCollectedCount() {
            let cnt = 0;
            for (const tile of visitedTiles) {
                if (levelMap[tile.y][tile.x] === 4) cnt++;
            }
            return cnt;
        }

        function goHome() {
            document.getElementById('menu').style.display = 'flex';
            document.getElementById('game-container').style.display = 'none';
            document.getElementById('message-overlay').style.display = 'none';
            currentMode = null;
            if (loopId) cancelAnimationFrame(loopId);
        }

        function resetGame() {
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (levelMap[y][x] === 2) {
                        playerPos = { x, y };
                    }
                }
            }

            isGameClear = false;
            fireworks = [];

            isDrawing = false;
            drawPath = [];
            const cx = playerPos.x * tileSize + tileSize / 2;
            const cy = playerPos.y * tileSize + tileSize / 2;
            drawPath.push({ x: cx, y: cy });

            historyStack = [];
            visitedTiles = [];
            visitedTiles.push({ x: playerPos.x, y: playerPos.y });

            hasKey = false;


            draw();
        }

        let loopId;
        function loop() {
            if (!currentMode) return;
            update();
            draw();
            loopId = requestAnimationFrame(loop);
        }

        function update() {
            if (isGameClear) {
                if (Math.random() < 0.1) createFirework();
                updateFireworks();
            }
        }

        /**
         * æç”»ã‚·ã‚¹ãƒ†ãƒ 
         */
        function draw() {
            if (!ctx || tileSize === 0 || !levelMap.length) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. ãƒãƒƒãƒ—
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = levelMap[y][x];
                    const px = x * tileSize;
                    const py = y * tileSize;

                    ctx.fillStyle = '#FFF8E1';
                    if ((x + y) % 2 === 0) ctx.fillStyle = '#FFECB3';
                    ctx.fillRect(px, py, tileSize, tileSize);

                    if (cell === 1) {
                        ctx.fillStyle = '#8D6E63';
                        ctx.fillRect(px + 2, py + 2, tileSize - 4, tileSize - 4);

                        ctx.fillStyle = '#6D4C41';
                        ctx.fillRect(px + 5, py + 8, tileSize - 10, tileSize / 4);
                        ctx.fillRect(px + 5, py + tileSize / 2 + 4, tileSize - 10, tileSize / 4);
                    }

                    if (cell === 2) {
                        drawEmoji('ğŸ ', px, py, 0.7);
                    }
                    if (cell === 3) {
                        drawEmoji('ğŸš©', px, py, 0.7);
                    }
                    if (cell === 4) {
                        let isCollected = false;
                        if (currentMode === 'B') {
                            if (visitedTiles.some(t => t.x === x && t.y === y)) {
                                isCollected = true;
                            }
                        }
                        if (!isCollected) {
                            drawEmoji('ğŸ', px, py, 0.6);
                        } else {
                            // å–å¾—æ¸ˆã¿è·¡åœ°
                            ctx.globalAlpha = 0.3;
                            drawEmoji('ğŸ', px, py, 0.4);
                            ctx.globalAlpha = 1.0;
                        }
                    }
                    if (cell === 5) { // Key
                        drawEmoji('ğŸ”‘', px, py, 0.7);
                    }
                    if (cell === 6) { // Door
                        drawEmoji('ğŸšª', px, py, 0.8);
                    }
                }
            }

            function drawEmoji(char, x, y, scale) {
                ctx.font = `${tileSize * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(char, x + tileSize / 2, y + tileSize / 2);
            }

            // 2. è¶³è·¡ (Mode B)
            if (currentMode === 'B') {
                for (const tile of visitedTiles) {
                    if (tile.x === playerPos.x && tile.y === playerPos.y) continue;

                    ctx.fillStyle = 'rgba(33, 150, 243, 0.3)';
                    ctx.fillRect(tile.x * tileSize + 2, tile.y * tileSize + 2, tileSize - 4, tileSize - 4);

                    drawEmoji('ğŸ¾', tile.x * tileSize, tile.y * tileSize, 0.4);
                }
            }

            // 3. ç·š (Mode A)
            if (currentMode === 'A' && drawPath.length > 0) {
                ctx.beginPath();
                ctx.lineWidth = tileSize / 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = 'rgba(255, 112, 67, 0.8)';
                ctx.moveTo(drawPath[0].x, drawPath[0].y);
                for (let i = 1; i < drawPath.length; i++) {
                    ctx.lineTo(drawPath[i].x, drawPath[i].y);
                }
                ctx.stroke();

                const last = drawPath[drawPath.length - 1];
                drawEmoji('âœï¸', last.x - tileSize / 2, last.y - tileSize, 0.6);
            }

            // 4. Player (Mode B)
            if (currentMode === 'B') {
                const px = playerPos.x * tileSize;
                const py = playerPos.y * tileSize;
                drawEmoji('ğŸ¶', px, py, 0.7);
            }

            // 5. Firework
            for (const fw of fireworks) {
                ctx.beginPath();
                ctx.fillStyle = fw.color;
                ctx.arc(fw.x, fw.y, fw.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        /**
         * Input Mode A
         */
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX = e.clientX;
            let clientY = e.clientY;
            if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function startDraw(e) {
            if (currentMode !== 'A' || isGameClear) return;
            e.preventDefault();
            isDrawing = true;
            addPoint(getPos(e));
        }

        function drawing(e) {
            if (!isDrawing || currentMode !== 'A' || isGameClear) return;
            e.preventDefault();
            addPoint(getPos(e));
        }

        function endDraw(e) {
            isDrawing = false;
        }

        function addPoint(pos) {
            const gridX = Math.floor(pos.x / tileSize);
            const gridY = Math.floor(pos.y / tileSize);

            if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize) return;

            if (levelMap[gridY][gridX] === 1) {
                isDrawing = false;
                return;
            }
            drawPath.push(pos);
            if (levelMap[gridY][gridX] === 3) {
                // Mode Aã¯ãƒªãƒ³ã‚´é–¢ä¿‚ãªãã‚´ãƒ¼ãƒ«ã§ã‚¯ãƒªã‚¢ï¼ˆç°¡å˜ï¼‰
                gameLevelComplete();
            }
        }

        /**
         * Input Mode B
         */
        function handleDPad(dir) {
            if (currentMode !== 'B' || isGameClear) return;

            let dx = 0; let dy = 0;
            if (dir === 'UP') dy = -1;
            if (dir === 'DOWN') dy = 1;
            if (dir === 'LEFT') dx = -1;
            if (dir === 'RIGHT') dx = 1;

            const nextX = playerPos.x + dx;
            const nextY = playerPos.y + dy;

            if (nextX < 0 || nextX >= gridSize || nextY < 0 || nextY >= gridSize) return;
            if (levelMap[nextY][nextX] === 1) return;

            // Key (5)
            if (levelMap[nextY][nextX] === 5) {
                hasKey = true;
                levelMap[nextY][nextX] = 0; // å–å¾—ã—ãŸã‚‰é“ã«ãªã‚‹
                const status = document.getElementById('status-text');
                status.textContent = 'ã‹ãã‚’ã‚²ãƒƒãƒˆã—ãŸã‚ˆï¼';
                status.style.color = 'orange';
            }

            // Door (6)
            if (levelMap[nextY][nextX] === 6) {
                if (hasKey) {
                    levelMap[nextY][nextX] = 0; // é–‹ã„ãŸã‚‰é“ã«ãªã‚‹
                    const status = document.getElementById('status-text');
                    status.textContent = 'ãƒ‰ã‚¢ãŒã‚ã„ãŸï¼';
                    status.style.color = 'blue';
                } else {
                    const status = document.getElementById('status-text');
                    status.textContent = 'ã‹ããŒãªã„ã¨ã‚ã‹ãªã„ã‚ˆï¼';
                    status.style.color = 'red';
                    // ç§»å‹•ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                    return;
                }
            }

            const isVisited = visitedTiles.some(t => t.x === nextX && t.y === nextY);
            if (isVisited) return;

            historyStack.push({
                pos: { ...playerPos },
                visitedCount: visitedTiles.length
            });

            playerPos = { x: nextX, y: nextY };
            visitedTiles.push({ x: nextX, y: nextY });

            updateStatusTextB();

            if (levelMap[nextY][nextX] === 3) {
                checkWinConditionB();
            }
        }

        function handleUndo() {
            if (currentMode !== 'B' || isGameClear) return;
            if (historyStack.length === 0) return;

            const lastState = historyStack.pop();
            playerPos = lastState.pos;
            visitedTiles.pop();
            updateStatusTextB();
            draw();
        }

        function checkWinConditionB() {
            let collected = getCollectedCount();

            let win = false;
            if (isExactCountMode) {
                // LV3: ã´ã£ãŸã‚Šã§ãªã„ã¨ãƒ€ãƒ¡
                win = (collected === targetItemCount);
            } else {
                // LV1, LV2: å…¨éƒ¨ã¨ã‚Œã°OKï¼ˆtargetItemCountã«ã¯ç·æ•°ãŒå…¥ã£ã¦ã„ã‚‹ï¼‰
                win = (collected >= targetItemCount);
            }

            if (win) {
                gameLevelComplete();
            } else {
                const status = document.getElementById('status-text');

                if (isExactCountMode && collected > targetItemCount) {
                    status.textContent = `ã¨ã‚Šã™ãï¼ã‚‚ã©ã£ã¦ã‚„ã‚ŠãªãŠã—ã¦ã­`;
                } else {
                    status.textContent = `ã¾ã è¶³ã‚Šãªã„ã‚ˆï¼`;
                    setTimeout(() => updateStatusTextB(), 1500);
                }
            }
        }

        function gameLevelComplete() {
            if (isGameClear) return;
            isGameClear = true;
            isDrawing = false;

            const overlay = document.getElementById('message-overlay');
            overlay.style.display = 'flex';

            const msgBox = overlay.querySelector('.message-box');
            msgBox.innerHTML = `
            <div>ğŸ‰ Level ${currentLevel} ã‚¯ãƒªã‚¢ï¼ ğŸ‰</div>
            ${currentLevel < TOTAL_LEVELS ?
                    '<button onclick="nextLevel()" style="background:#fff; color:orange; border:none; padding:10px 20px; font-size:1.5rem; border-radius:10px; margin-top:20px; cursor:pointer; box-shadow:0 4px #ccc;">ã¤ãã¸ â¡</button>' :
                    '<div style="font-size:1.2rem; margin-top:10px;">ãœã‚“ã¶ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ï¼ğŸ†</div><div style="font-size:1rem; margin-top:10px;">ã‚¿ãƒƒãƒã—ã¦ãƒ›ãƒ¼ãƒ ã¸</div>'}
        `;

            for (let i = 0; i < 50; i++) createFirework();
        }

        window.nextLevel = function (event) {
            if (event) event.stopPropagation();
            if (currentLevel < TOTAL_LEVELS) {
                startGame(currentMode, currentLevel + 1);
            } else {
                goHome();
            }
        };

        setTimeout(() => {
            const overlay = document.getElementById('message-overlay');
            overlay.onclick = (e) => {
                if (e.target.tagName === 'BUTTON') return;
                if (currentLevel >= TOTAL_LEVELS) {
                    goHome();
                }
                if (currentLevel < TOTAL_LEVELS) {
                    startGame(currentMode, currentLevel + 1);
                }
            };
        }, 100);

        /**
         * Effect
         */
        function createFirework() {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const color = `hsl(${Math.random() * 360}, 100%, 70%)`;
            for (let i = 0; i < 20; i++) {
                fireworks.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 5 + 2,
                    color: color,
                    life: 1.0
                });
            }
        }

        function updateFireworks() {
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const p = fireworks[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life -= 0.02;
                p.size *= 0.95;

                if (p.life <= 0) {
                    fireworks.splice(i, 1);
                }
            }
        }

    </script>
</body>

</html>