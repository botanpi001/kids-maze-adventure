<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>çŸ¥è‚²è¿·è·¯ã‚¢ãƒ—ãƒª</title>
    <style>
        /* å…¨ä½“ã®ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
            background-color: #FFF9C4;
            /* ãƒ‘ã‚¹ãƒ†ãƒ«ã‚¤ã‚¨ãƒ­ãƒ¼ */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ */
        #menu {
            display: flex;
            flex-direction: column;
            gap: 20px;
            text-align: center;
        }

        h1 {
            color: #FF7043;
            /* ãƒãƒƒãƒ—ãªã‚ªãƒ¬ãƒ³ã‚¸ */
            font-size: 2.5rem;
            margin-bottom: 30px;
            text-shadow: 2px 2px 0px #FFF;
        }

        .mode-btn {
            background-color: #4DB6AC;
            /* ãƒ‘ã‚¹ãƒ†ãƒ«ã‚°ãƒªãƒ¼ãƒ³ */
            color: white;
            border: none;
            border-radius: 20px;
            padding: 20px 40px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 6px 0 #00897B;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .mode-btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #00897B;
        }

        .mode-btn.purple {
            background-color: #9575CD;
            box-shadow: 0 6px 0 #5E35B1;
        }

        .mode-btn.purple:active {
            box-shadow: 0 2px 0 #5E35B1;
        }

        /* ã‚²ãƒ¼ãƒ ç”»é¢ */
        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        /* ã‚­ãƒ£ãƒ³ãƒã‚¹ */
        canvas {
            background-color: #FFFFFF;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            margin: 10px;
            touch-action: none;
            /* ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãªã©ã‚’ç„¡åŠ¹åŒ– */
        }

        /* UIãƒ‘ãƒãƒ« */
        #ui-panel {
            width: 90%;
            max-width: 400px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .nav-btn {
            background-color: #FFAB91;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 0 #D84315;
            color: white;
        }

        .nav-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #D84315;
        }

        /* D-Pad controls for Mode B */
        #d-pad {
            display: none;
            /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯éè¡¨ç¤º */
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .d-btn {
            background-color: #64B5F6;
            border: none;
            border-radius: 15px;
            width: 80px;
            height: 60px;
            font-size: 2rem;
            color: white;
            cursor: pointer;
            box-shadow: 0 5px 0 #1565C0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .d-btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #1565C0;
        }

        #undo-btn {
            background-color: #F06292;
            box-shadow: 0 5px 0 #AD1457;
            font-size: 1rem;
        }

        #undo-btn:active {
            box-shadow: 0 2px 0 #AD1457;
        }

        /* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .message-box {
            background: orange;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 2rem;
            border: 5px solid white;
            animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popUp {
            0% {
                transform: scale(0);
            }

            100% {
                transform: scale(1);
            }
        }

        /* ã‚«ãƒ³ã‚¿ãƒ³ãªãƒªã‚»ãƒƒãƒˆCSS */
        * {
            box-sizing: border-box;
        }
    </style>
</head>

<body>

    <!-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ -->
    <div id="menu">
        <h1>ğŸ¶ çŸ¥è‚²è¿·è·¯ ğŸ</h1>
        <button class="mode-btn" onclick="startGame('A')">âœï¸ ãŠãˆã‹ãè¿·è·¯</button>
        <button class="mode-btn purple" onclick="startGame('B')">ğŸ—ºï¸ ã¼ã†ã‘ã‚“è¿·è·¯</button>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
    <div id="game-container">
        <div id="ui-panel">
            <button class="nav-btn" onclick="goHome()">ğŸ </button>
            <div id="status-text" style="font-size: 1.2rem; font-weight: bold; color:#555;"></div>
            <div style="width: 50px;"></div> <!-- ã‚¹ãƒšãƒ¼ã‚µãƒ¼ -->
        </div>

        <canvas id="gameCanvas"></canvas>

        <!-- ãƒ¢ãƒ¼ãƒ‰Bç”¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ -->
        <div id="d-pad">
            <div style="grid-column: 2;">
                <button class="d-btn" onclick="handleDPad('UP')">â¬†ï¸</button>
            </div>
            <div style="grid-column: 1; grid-row: 2;">
                <button class="d-btn" onclick="handleDPad('LEFT')">â¬…ï¸</button>
            </div>
            <div style="grid-column: 2; grid-row: 2;">
                <button class="d-btn" onclick="handleDPad('DOWN')">â¬‡ï¸</button>
            </div>
            <div style="grid-column: 3; grid-row: 2;">
                <button class="d-btn" onclick="handleDPad('RIGHT')">â¡ï¸</button>
            </div>
        </div>

        <!-- ãƒ¢ãƒ¼ãƒ‰Bç”¨ Undoãƒœã‚¿ãƒ³ (D-Padã®ä¸‹ã«é…ç½®) -->
        <div id="d-pad-sub" style="margin-top: 15px; display: none;">
            <button id="undo-btn" class="d-btn" onclick="handleUndo()">ï¼‘ã¤ã‚‚ã©ã‚‹</button>
        </div>
    </div>

    <!-- ã‚¯ãƒªã‚¢ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ -->
    <div id="message-overlay" onclick="goHome()">
        <div class="message-box">
            <div>ğŸ‰ ã‚¯ãƒªã‚¢ï¼ ğŸ‰</div>
            <div style="font-size: 1rem; margin-top: 10px;">ã‚¿ãƒƒãƒã—ã¦ãƒ›ãƒ¼ãƒ ã¸</div>
        </div>
    </div>

    <script>
        /**
         * å®šæ•°ãƒ»è¨­å®š
         */
        const TILE_SIZE = 40; // ã‚°ãƒªãƒƒãƒ‰ã®åŸºæœ¬ã‚µã‚¤ã‚ºï¼ˆãƒªã‚µã‚¤ã‚ºæ™‚ã«å†è¨ˆç®—ï¼‰
        const GRID_SIZE = 10; // 10x10
        const TOTAL_LEVELS = 30;

        /**
         * å¤‰æ•°
         */
        let currentMode = null; // 'A' or 'B'
        let currentLevel = 1;
        let canvas, ctx;
        let tileSize = 0;

        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
        let levelMap = []; // ç¾åœ¨ã®ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿
        let playerPos = { x: 1, y: 1 };
        let collectedItems = 0;
        let totalItems = 0;
        let isGameClear = false;

        // ãƒ¢ãƒ¼ãƒ‰Aç”¨
        let isDrawing = false;
        let drawPath = []; // {x, y} screen coordinates

        // ãƒ¢ãƒ¼ãƒ‰Bç”¨
        let historyStack = []; // å±¥æ­´ï¼ˆUndoç”¨ï¼‰
        let visitedTiles = []; // {x, y} grid coordinates

        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨
        let fireworks = [];

        /**
         * è¿·è·¯ç”Ÿæˆã‚¯ãƒ©ã‚¹
         */
        class MazeGenerator {
            static generate(level) {
                // 1. å…¨ã¦å£ã§åŸ‹ã‚ã‚‹
                let map = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(1));

                // 2. ç©´æ˜ã‚Šæ³•ãªã©ã§è¿·è·¯ç”Ÿæˆ (å¥‡æ•°åº§æ¨™ã‚’é“ã«ã™ã‚‹)
                // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ (1, 1)
                this.carve(map, 1, 1);

                // 3. ã‚¹ã‚¿ãƒ¼ãƒˆã¨ã‚´ãƒ¼ãƒ«é…ç½®
                map[1][1] = 2; // Start
                // ã‚´ãƒ¼ãƒ«ã¯å³ä¸‹ä»˜è¿‘ã®é“ã‚’æ¢ã™
                let gx = GRID_SIZE - 2;
                let gy = GRID_SIZE - 2;
                while (map[gy][gx] === 1) {
                    // å³ä¸‹ãŒå£ãªã‚‰å°‘ã—ãšã‚‰ã™ï¼ˆç©´æ˜ã‚Šæ³•ãªã‚‰åŸºæœ¬å³ä¸‹ã¾ã§æ˜ã‚Œã‚‹ã¯ãšã ãŒå¿µã®ãŸã‚ï¼‰
                    if (gx > 1) gx--;
                    else { gx = GRID_SIZE - 2; gy--; }
                }
                map[gy][gx] = 3; // Goal

                // 4. æ­£è§£ãƒ«ãƒ¼ãƒˆã‚’æ¢ã™ (BFS)
                const path = this.findPath(map, { x: 1, y: 1 }, { x: gx, y: gy });

                // 5. ã‚¢ã‚¤ãƒ†ãƒ é…ç½® (Mode Bã®é›£æ˜“åº¦èª¿æ•´)
                // ç¢ºå®Ÿã«ã‚¯ãƒªã‚¢ã§ãã‚‹ã‚ˆã†ã«ã€Œæ­£è§£ãƒ«ãƒ¼ãƒˆä¸Šã€ã«ã ã‘ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç½®ã
                // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ã‚¢ã‚¤ãƒ†ãƒ æ•°ã‚’å¢—ã‚„ã™ï¼ˆæœ€å¤§5å€‹ãã‚‰ã„ï¼‰
                if (path && path.length > 2) {
                    let itemCount = 2 + Math.floor(level / 10);
                    // ãƒ‘ã‚¹ã®ä¸­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«é™¤ãï¼‰
                    const candidates = path.slice(1, path.length - 1);
                    // ã‚·ãƒ£ãƒƒãƒ•ãƒ«
                    for (let i = candidates.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
                    }

                    for (let k = 0; k < Math.min(itemCount, candidates.length); k++) {
                        map[candidates[k].y][candidates[k].x] = 4;
                    }
                }

                return map;
            }

            static carve(map, x, y) {
                const directions = [
                    { dx: 0, dy: -2 }, // Up
                    { dx: 0, dy: 2 },  // Down
                    { dx: -2, dy: 0 }, // Left
                    { dx: 2, dy: 0 }   // Right
                ];

                // ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ£ãƒƒãƒ•ãƒ«
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }

                map[y][x] = 0; // é“ã«ã™ã‚‹

                for (const dir of directions) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;

                    // ç¯„å›²å†…ã‹ã¤å£ãªã‚‰æ˜ã‚Šé€²ã‚€
                    if (nx > 0 && nx < GRID_SIZE - 1 && ny > 0 && ny < GRID_SIZE - 1 && map[ny][nx] === 1) {
                        map[y + dir.dy / 2][x + dir.dx / 2] = 0; // ä¸­é–“ã®å£ã‚‚é“ã«ã™ã‚‹
                        this.carve(map, nx, ny);
                    }
                }
            }

            static findPath(map, start, goal) {
                const q = [[start]];
                const visited = new Set();
                visited.add(`${start.x},${start.y}`);

                while (q.length > 0) {
                    const path = q.shift();
                    const curr = path[path.length - 1];

                    if (curr.x === goal.x && curr.y === goal.y) return path;

                    const dirs = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];
                    for (const d of dirs) {
                        const nx = curr.x + d.x;
                        const ny = curr.y + d.y;
                        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && map[ny][nx] !== 1) {
                            if (!visited.has(`${nx},${ny}`)) {
                                visited.add(`${nx},${ny}`);
                                q.push([...path, { x: nx, y: ny }]);
                            }
                        }
                    }
                }
                return null;
            }
        }

        /**
         * åˆæœŸåŒ–
         */
        window.onload = () => {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (Canvas)
            canvas.addEventListener('mousedown', startDraw);
            canvas.addEventListener('mousemove', drawing);
            canvas.addEventListener('mouseup', endDraw);
            canvas.addEventListener('mouseout', endDraw); // ç”»é¢å¤–ã«å‡ºãŸæ™‚ã‚‚çµ‚äº†
            canvas.addEventListener('touchstart', startDraw, { passive: false });
            canvas.addEventListener('touchmove', drawing, { passive: false });
            canvas.addEventListener('touchend', endDraw);

            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ãƒ»PCç”¨ï¼‰
            window.addEventListener('keydown', (e) => {
                if (currentMode === 'B' && !isGameClear) {
                    if (e.key === 'ArrowUp') handleDPad('UP');
                    if (e.key === 'ArrowDown') handleDPad('DOWN');
                    if (e.key === 'ArrowLeft') handleDPad('LEFT');
                    if (e.key === 'ArrowRight') handleDPad('RIGHT');
                }
            });

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        };

        function resizeCanvas() {
            // ç”»é¢å¹…ã«åˆã‚ã›ã¦ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’èª¿æ•´
            const maxSize = Math.min(window.innerWidth - 40, window.innerHeight - 300); // UIåˆ†ã‚’å¼•ã
            const size = Math.floor(maxSize / GRID_SIZE) * GRID_SIZE;
            canvas.width = size;
            canvas.height = size;
            tileSize = size / GRID_SIZE;
            draw();
        }

        /**
         * ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡
         */
        function startGame(mode, level = 1) {
            currentMode = mode;
            currentLevel = level;

            document.getElementById('menu').style.display = 'none';
            document.getElementById('game-container').style.display = 'flex';
            document.getElementById('message-overlay').style.display = 'none'; // éè¡¨ç¤ºç¢ºå®Ÿã«

            // ãƒ¢ãƒ¼ãƒ‰åˆ¥UIåˆ‡ã‚Šæ›¿ãˆ
            const dPad = document.getElementById('d-pad');
            const dPadSub = document.getElementById('d-pad-sub');
            const statusText = document.getElementById('status-text');

            if (mode === 'B') {
                dPad.style.display = 'grid';
                dPadSub.style.display = 'block';
                statusText.textContent = `Lv.${currentLevel} ğŸã‚’ã‚ã¤ã‚ã¦ã‚´ãƒ¼ãƒ«ã¸ï¼`;
            } else {
                dPad.style.display = 'none';
                dPadSub.style.display = 'none';
                statusText.textContent = 'ã‚†ã³ã§ãªãã£ã¦ã­ï¼';
            }

            // ãƒãƒƒãƒ—ç”Ÿæˆ
            levelMap = MazeGenerator.generate(currentLevel);
            resetGame();
            loop();
        }

        function goHome() {
            document.getElementById('menu').style.display = 'flex';
            document.getElementById('game-container').style.display = 'none';
            document.getElementById('message-overlay').style.display = 'none';
            currentMode = null;
            cancelAnimationFrame(loopId); // ãƒ«ãƒ¼ãƒ—åœæ­¢
        }

        function resetGame() {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã‚’ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã¸
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (levelMap[y][x] === 2) {
                        playerPos = { x, y };
                    }
                }
            }

            countItems();
            collectedItems = 0;
            isGameClear = false;
            fireworks = [];

            // ãƒ¢ãƒ¼ãƒ‰Aãƒªã‚»ãƒƒãƒˆ
            isDrawing = false;
            drawPath = [];
            // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã‚’ä¸­å¿ƒã«ãƒ‘ã‚¹ã®åˆæœŸç‚¹ã¨ã™ã‚‹
            const cx = playerPos.x * tileSize + tileSize / 2;
            const cy = playerPos.y * tileSize + tileSize / 2;
            drawPath.push({ x: cx, y: cy });

            // ãƒ¢ãƒ¼ãƒ‰Bãƒªã‚»ãƒƒãƒˆ
            historyStack = [];
            visitedTiles = [];
            visitedTiles.push({ x: playerPos.x, y: playerPos.y });

            draw();
        }

        function countItems() {
            totalItems = 0;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (levelMap[y][x] === 4) totalItems++;
                }
            }
        }

        let loopId;
        /**
         * ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
         */
        function loop() {
            if (!currentMode) return;

            update();
            draw();

            loopId = requestAnimationFrame(loop);
        }

        function update() {
            if (isGameClear) {
                // èŠ±ç«æ›´æ–°
                if (Math.random() < 0.1) createFirework(); // å¢—ã‚„ã™
                updateFireworks();
            }
        }

        /**
         * æç”»ã‚·ã‚¹ãƒ†ãƒ 
         */
        function draw() {
            if (!ctx || tileSize === 0 || !levelMap.length) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. ãƒãƒƒãƒ—æç”»
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = levelMap[y][x];
                    const px = x * tileSize;
                    const py = y * tileSize;

                    // åºŠ
                    ctx.fillStyle = '#FFF8E1';
                    if ((x + y) % 2 === 0) ctx.fillStyle = '#FFECB3'; // ãƒã‚§ãƒƒã‚¯æŸ„
                    ctx.fillRect(px, py, tileSize, tileSize);

                    // å£
                    if (cell === 1) {
                        ctx.fillStyle = '#8D6E63'; // èŒ¶è‰²ã„ãƒ¬ãƒ³ã‚¬é¢¨
                        ctx.fillRect(px + 2, py + 2, tileSize - 4, tileSize - 4);
                        // å£ã®è£…é£¾
                        ctx.fillStyle = '#6D4C41';
                        ctx.fillRect(px + 5, py + 8, tileSize - 10, tileSize / 4);
                        ctx.fillRect(px + 5, py + tileSize / 2 + 4, tileSize - 10, tileSize / 4);
                    }

                    // ã‚¹ã‚¿ãƒ¼ãƒˆ
                    if (cell === 2) {
                        ctx.font = `${tileSize * 0.6}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ğŸ ', px + tileSize / 2, py + tileSize / 2);
                    }

                    // ã‚´ãƒ¼ãƒ«
                    if (cell === 3) {
                        ctx.font = `${tileSize * 0.6}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ğŸš©', px + tileSize / 2, py + tileSize / 2);
                    }

                    // ã‚¢ã‚¤ãƒ†ãƒ 
                    if (cell === 4) {
                        let isCollected = false;
                        if (currentMode === 'B') {
                            if (visitedTiles.some(t => t.x === x && t.y === y)) {
                                isCollected = true;
                            }
                        }
                        // Mode Aã§ã‚‚è¡¨ç¤ºã™ã‚‹ï¼ˆé£¾ã‚Šï¼‰

                        if (!isCollected) {
                            ctx.font = `${tileSize * 0.6}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('ğŸ', px + tileSize / 2, py + tileSize / 2);
                        }
                    }
                }
            }

            // 2. ãƒ¢ãƒ¼ãƒ‰Bå›ºæœ‰æç”»ï¼šè¶³è·¡
            if (currentMode === 'B') {
                for (const tile of visitedTiles) {
                    // ç¾åœ¨åœ°ä»¥å¤–ã‚’æç”»
                    if (tile.x === playerPos.x && tile.y === playerPos.y) continue;

                    // é’ã„åŠé€æ˜ã‚¿ã‚¤ãƒ«
                    ctx.fillStyle = 'rgba(33, 150, 243, 0.3)';
                    ctx.fillRect(tile.x * tileSize + 2, tile.y * tileSize + 2, tileSize - 4, tileSize - 4);

                    // è¶³è·¡ãƒãƒ¼ã‚¯
                    ctx.font = `${tileSize * 0.4}px Arial`;
                    ctx.fillStyle = '#1565C0'; // æ¿ƒã„é’
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ğŸ¾', tile.x * tileSize + tileSize / 2, tile.y * tileSize + tileSize / 2);
                }
            }

            // 3. ãƒ¢ãƒ¼ãƒ‰Aå›ºæœ‰æç”»ï¼šç·š
            if (currentMode === 'A' && drawPath.length > 0) {
                ctx.beginPath();
                ctx.lineWidth = tileSize / 3; // å¤ªã
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = 'rgba(255, 112, 67, 0.8)'; // ã‚ªãƒ¬ãƒ³ã‚¸åŠé€æ˜
                ctx.moveTo(drawPath[0].x, drawPath[0].y);
                for (let i = 1; i < drawPath.length; i++) {
                    ctx.lineTo(drawPath[i].x, drawPath[i].y);
                }
                ctx.stroke();

                // å…ˆé ­ã«ãƒšãƒ³å…ˆãƒãƒ¼ã‚¯
                const last = drawPath[drawPath.length - 1];
                ctx.font = `${tileSize * 0.6}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('âœï¸', last.x, last.y - tileSize / 2); // å°‘ã—ä¸Šã«
            }

            // 4. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»ï¼ˆãƒ¢ãƒ¼ãƒ‰Bã®ã¿ï¼‰
            if (currentMode === 'B') {
                const px = playerPos.x * tileSize;
                const py = playerPos.y * tileSize;
                ctx.font = `${tileSize * 0.7}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ğŸ¶', px + tileSize / 2, py + tileSize / 2);
            }

            // 5. èŠ±ç«
            for (const fw of fireworks) {
                ctx.beginPath();
                ctx.fillStyle = fw.color;
                ctx.arc(fw.x, fw.y, fw.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        /**
         * å…¥åŠ›å‡¦ç† - ãƒ¢ãƒ¼ãƒ‰A (Mouse/Touch)
         */
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX = e.clientX;
            let clientY = e.clientY;
            if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function startDraw(e) {
            if (currentMode !== 'A' || isGameClear) return;
            e.preventDefault();

            isDrawing = true;
            addPoint(getPos(e));
        }

        function drawing(e) {
            if (!isDrawing || currentMode !== 'A' || isGameClear) return;
            e.preventDefault();
            addPoint(getPos(e));
        }

        function endDraw(e) {
            isDrawing = false;
        }

        function addPoint(pos) {
            const gridX = Math.floor(pos.x / tileSize);
            const gridY = Math.floor(pos.y / tileSize);

            // ç¯„å›²å¤–ãƒã‚§ãƒƒã‚¯
            if (gridX < 0 || gridX >= GRID_SIZE || gridY < 0 || gridY >= GRID_SIZE) return;

            // å£ãƒã‚§ãƒƒã‚¯
            if (levelMap[gridY][gridX] === 1) {
                isDrawing = false;
                return;
            }

            drawPath.push(pos);

            // ã‚´ãƒ¼ãƒ«åˆ¤å®š
            if (levelMap[gridY][gridX] === 3) {
                gameLevelComplete();
            }
        }

        /**
         * å…¥åŠ›å‡¦ç† - ãƒ¢ãƒ¼ãƒ‰B (D-Pad)
         */
        function handleDPad(dir) {
            if (currentMode !== 'B' || isGameClear) return;

            let dx = 0;
            let dy = 0;
            if (dir === 'UP') dy = -1;
            if (dir === 'DOWN') dy = 1;
            if (dir === 'LEFT') dx = -1;
            if (dir === 'RIGHT') dx = 1;

            const nextX = playerPos.x + dx;
            const nextY = playerPos.y + dy;

            if (nextX < 0 || nextX >= GRID_SIZE || nextY < 0 || nextY >= GRID_SIZE) return;
            if (levelMap[nextY][nextX] === 1) return;

            const isVisited = visitedTiles.some(t => t.x === nextX && t.y === nextY);
            if (isVisited) {
                // æˆ»ã‚Œãªã„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆã·ã‚‹ã£ã¨éœ‡ãˆã‚‹ãªã©ï¼‰å…¥ã‚ŒãŸã„ãŒä»Šå›ã¯çœç•¥
                return;
            }

            historyStack.push({
                pos: { ...playerPos },
                visitedCount: visitedTiles.length
            });

            playerPos = { x: nextX, y: nextY };
            visitedTiles.push({ x: nextX, y: nextY });

            if (levelMap[nextY][nextX] === 3) {
                checkWinConditionB();
            }
        }

        function handleUndo() {
            if (currentMode !== 'B' || isGameClear) return;
            if (historyStack.length === 0) return;

            const lastState = historyStack.pop();
            playerPos = lastState.pos;
            visitedTiles.pop();
            draw();
        }

        function checkWinConditionB() {
            let collectedCount = 0;
            for (const tile of visitedTiles) {
                if (levelMap[tile.y][tile.x] === 4) {
                    collectedCount++;
                }
            }

            if (collectedCount >= totalItems) {
                gameLevelComplete();
            } else {
                const status = document.getElementById('status-text');
                const remaining = totalItems - collectedCount;
                status.textContent = `ã‚ã¨ ${remaining}ã“ï¼`;
                // ã™ãæˆ»ã™
                setTimeout(() => {
                    if (!isGameClear) status.textContent = `Lv.${currentLevel} ğŸã‚’ã‚ã¤ã‚ã¦ã‚´ãƒ¼ãƒ«ã¸ï¼`;
                }, 1500);
            }
        }

        function gameLevelComplete() {
            if (isGameClear) return;
            isGameClear = true;
            isDrawing = false;

            const overlay = document.getElementById('message-overlay');
            overlay.style.display = 'flex';

            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹æ›´æ–°
            const msgBox = overlay.querySelector('.message-box');
            msgBox.innerHTML = `
            <div>ğŸ‰ Level ${currentLevel} ã‚¯ãƒªã‚¢ï¼ ğŸ‰</div>
            ${currentLevel < TOTAL_LEVELS ?
                    '<button onclick="nextLevel()" style="background:#fff; color:orange; border:none; padding:10px 20px; font-size:1.5rem; border-radius:10px; margin-top:20px; cursor:pointer;">ã¤ãã¸ â¡</button>' :
                    '<div style="font-size:1.2rem; margin-top:10px;">ãœã‚“ã¶ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ï¼ğŸ†</div><div style="font-size:1rem; margin-top:10px;">ã‚¿ãƒƒãƒã—ã¦ãƒ›ãƒ¼ãƒ ã¸</div>'}
        `;

            // æœ€å¾Œä»¥å¤–ã®æ™‚ã¯ã‚¯ãƒªãƒƒã‚¯ã§ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‰ãªã„ã‚ˆã†ã«ã€ã‚¤ãƒ™ãƒ³ãƒˆä¼æ’­ã‚’æ­¢ã‚ã‚‹å·¥å¤«ãŒå¿…è¦ã ãŒ
            // ã‚·ãƒ³ãƒ—ãƒ«ã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®onclickã¯ã€Œå…¨ã‚¯ãƒªæ™‚ã€ã¾ãŸã¯ã€Œæ¬¡ã¸ãƒœã‚¿ãƒ³ä»¥å¤–ã‚’ã‚¯ãƒªãƒƒã‚¯æ™‚ã€ã«ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹ã‚ˆã†ã«ã™ã‚‹
            // ã“ã“ã§ã¯ nextLevel() ã‚’å‘¼ã¶ãƒœã‚¿ãƒ³ã‚’ä½œã£ãŸã®ã§ã€ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤å…¨ä½“ã®onclickã‚¤ãƒ™ãƒ³ãƒˆã¨ç«¶åˆã—ãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚
            // -> nextLevel()å†…ã§ stopPropagation ã™ã‚‹ã€‚

            // èŠ±ç«é€£ç™º
            for (let i = 0; i < 50; i++) createFirework();
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã«è¿½åŠ ï¼ˆHTMLã‹ã‚‰å‘¼ã¶ãŸã‚ï¼‰
        window.nextLevel = function (event) {
            if (event) event.stopPropagation(); // è¦ªã®goHomeç™ºç«ã‚’é˜²ã
            if (currentLevel < TOTAL_LEVELS) {
                startGame(currentMode, currentLevel + 1);
            } else {
                goHome();
            }
        };

        // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚¯ãƒªãƒƒã‚¯æ™‚ã®æŒ™å‹•ä¿®æ­£
        // message-overlayã®onclick="goHome()"ã‚’å‰Šé™¤ã—ã€å‹•çš„ã«åˆ¶å¾¡ã—ãŸã»ã†ãŒå®‰å…¨ã ãŒã€
        // æ—¢å­˜HTMLã‚’ç”Ÿã‹ã™ãªã‚‰ã€goHomeå´ã§åˆ¶å¾¡ã™ã‚‹ã€‚
        // ä»Šå›ã¯HTMLå´ã‚’å¤‰æ›´ã§ããªã„ï¼ˆreplace_file_contentã®åˆ¶é™ï¼‰ã®ã§ã€
        // JSã§ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä¸Šæ›¸ãã™ã‚‹ã€‚
        setTimeout(() => {
            const overlay = document.getElementById('message-overlay');
            overlay.onclick = (e) => {
                // ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸå ´åˆã¯ç„¡è¦–ï¼ˆãƒãƒ–ãƒªãƒ³ã‚°ã§æ¥ã‚‹ã‘ã©å¿µã®ãŸã‚ï¼‰
                if (e.target.tagName === 'BUTTON') return;
                // å…¨ã‚¯ãƒªã¾ãŸã¯ã€æ¬¡ã¸ãƒœã‚¿ãƒ³ãŒãªã„å ´æ‰€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰Homeã¸
                if (currentLevel >= TOTAL_LEVELS) {
                    goHome();
                }
                // ã¾ã ç¶šãå ´åˆã¯ã€Homeã«æˆ»ã‚‹ã‹è¿·ã†ãŒâ€¦
                // 4æ­³å…ãŒèª¤ã£ã¦é–‰ã˜ã¦ã—ã¾ã†ã®ã‚’é˜²ããŸã‚ã€æ¬¡ã¸ãƒœã‚¿ãƒ³ãŒã‚ã‚‹ã¨ãã¯Homeã«æˆ»ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ï¼Ÿ
                // ã„ã‚„ã€ã‚„ã‚ãŸã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚
                // å‹•ä½œã‚’æ˜ç¢ºã«ã™ã‚‹ãŸã‚ã€ã€Œãƒ›ãƒ¼ãƒ ã¸ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªã‚¢ç”»é¢ã«ã‚‚å‡ºã™ã®ãŒãƒ™ã‚¹ãƒˆã ãŒã€
                // æ—¢å­˜UIç¶­æŒãªã‚‰ã€ã€Œã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚¿ãƒƒãƒ—ã€ï¼ã€Œæ¬¡ã¸ã€ã¾ãŸã¯ã€Œãƒ›ãƒ¼ãƒ ï¼ˆå…¨ã‚¯ãƒªæ™‚ï¼‰ã€ãŒç›´æ„Ÿçš„ã€‚
                if (currentLevel < TOTAL_LEVELS) {
                    startGame(currentMode, currentLevel + 1);
                }
            };
        }, 100);

        /**
         * èŠ±ç«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
         */
        function createFirework() {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const color = `hsl(${Math.random() * 360}, 100%, 70%)`;
            for (let i = 0; i < 20; i++) {
                fireworks.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 5 + 2,
                    color: color,
                    life: 1.0
                });
            }
        }

        function updateFireworks() {
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const p = fireworks[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2; // gravity
                p.life -= 0.02;
                p.size *= 0.95;

                if (p.life <= 0) {
                    fireworks.splice(i, 1);
                }
            }
        }

    </script>
</body>

</html>